<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kubernetes系列之一：安装步骤]]></title>
    <url>%2F2017%2FKubernetes_Series_One_Installation%2F</url>
    <content type="text"><![CDATA[Docker是一个很好的东西，特别是在和微服务相结合之后。但是在服务增多，同时需要增多服务节点时，过多的Docker容器的管理就变得很麻烦。Kubernetes就是一款Google发布的开源的容器集群管理软件，它非常利于对Docker容器集群做到自动化部署、管理，能弹性地调整容器的个数、扩展性能，自动维护容器。本文主要介绍Kubernetes的安装步骤以及部分常用插件的安装。 1. Kubernetes安装以下是两个节点的部署示例，下表为各节点的IP信息。 节点 主机名 IP地址 master k8s-master 192.168.12.210 node1 k8s-node1 192.168.12.211 注意：需要所有节点都应该关闭防火墙12systemctl disable firewalld #禁止系统启动时服务自启动systemctl stop firewalld #停止服务 系统/软件版本 系统/软件 版本 centos 7.3 docker 1.12.6 kubernetes 1.5.2 1.1. master节点安装1.1.1. 修改master的主机信息首先修改master节点的hostname为k8s-master1hostnamectl set-hostname k8s-master 添加hosts文件的内容12echo "k8s-master 192.168.12.210" &gt;&gt; /etc/hostsecho "k8s-node1 192.168.12.211" &gt;&gt; /etc/hosts 1.1.2. 安装kubernetes、etcd、flannel使用yum来安装kurbernets1yum install -y kubernetes etcd flannel 1.1.3. 修改kubernetes的配置文件查看/etc/kubernetes下的配置文件12345678ll /etc/kubernetes/total 24-rw-r--r--. 1 root root 1028 Sep 1 04:47 apiserver-rw-r--r--. 1 root root 656 Aug 30 03:27 config-rw-r--r--. 1 root root 189 Mar 6 2017 controller-manager-rw-r--r--. 1 root root 768 Aug 31 01:15 kubelet-rw-r--r--. 1 root root 103 Mar 6 2017 proxy-rw-r--r--. 1 root root 111 Mar 6 2017 scheduler 修改apiserver1234567891011# The address on the local server to listen to.KUBE_API_ADDRESS="--insecure-bind-address=0.0.0.0"# Comma separated list of nodes in the etcd clusterKUBE_ETCD_SERVERS="--etcd-servers=http://127.0.0.1:2379"# Address range to use for servicesKUBE_SERVICE_ADDRESSES="--service-cluster-ip-range=10.254.0.0/16"# default admission control policies# 去除了ServiceAccount--需要认证KUBE_ADMISSION_CONTROL="--admission-control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ResourceQuota"# Add your own!KUBE_API_ARGS="" 修改config1234567KUBE_LOGTOSTDERR="--logtostderr=true"# journal message level, 0 is debugKUBE_LOG_LEVEL="--v=0"# Should this cluster be allowed to run privileged docker containersKUBE_ALLOW_PRIV="--allow-privileged=false"# How the controller-manager, scheduler, and proxy find the apiserverKUBE_MASTER="--master=http://k8s-master:8080" 修改kubelet123456789# The address for the info server to serve on (set to 0.0.0.0 or "" for all interfaces)KUBELET_ADDRESS="--address=0.0.0.0"# You may leave this blank to use the actual hostnameKUBELET_HOSTNAME="--hostname-override=k8s-master"# location of the api-serverKUBELET_API_SERVER="--api-servers=http://k8s-master:8080"# pod infrastructure container# 这个地址是使用的私有的harbor地址（docker images的仓库）KUBELET_POD_INFRA_CONTAINER="--pod-infra-container-image=192.168.12.200/myproj/pause-amd64:3.0" 1.1.4. 配置etcd123vi /etc/etcd/etcd.confETCD_LISTEN_CLIENT_URLS="http://0.0.0.0:2379"ETCD_ADVERTISE_CLIENT_URLS="http://0.0.0.0:2379" 1.1.5. 注册&amp;配置FLANNEL12etcdctl mkdir /kube-centos/networketcdctl mk /kube-centos/network/config "&#123; \"Network\": \"172.30.0.0/16\", \"SubnetLen\": 24, \"Backend\": &#123; \"Type\": \"vxlan\" &#125; &#125;" 1234vi /etc/sysconfig/flanneldFLANNEL_ETCD="http://k8s-master:2379"FLANNEL_ETCD_KEY="/kube-centos/network"FLANNEL_OPTIONS="" 1.1.6. 重启服务12345for SERVICES in etcd kube-apiserver kube-controller-manager kube-scheduler flanneld; do systemctl restart $SERVICES systemctl enable $SERVICES systemctl status $SERVICESdone 1.2. node节点安装1.2.1. 修改node1的主机信息首先修改node1节点的hostname为k8s-node11hostnamectl set-hostname k8s-node1 添加hosts文件的内容12echo "k8s-master 192.168.12.210k8s-node1 192.168.12.211" &gt;&gt; /etc/hosts 1.2.2. 安装kubernetes和flannel使用yum来安装kurbernets1yum install -y kubernetes-node flannel 1.2.3. 修改kubernetes的配置文件查看/etc/kubernetes下的配置文件12345ll /etc/kubernetes/total 12-rw-r--r--. 1 root root 655 Aug 30 03:41 config-rw-r--r--. 1 root root 769 Aug 30 22:59 kubelet-rw-r--r--. 1 root root 103 Mar 6 2017 proxy 修改config文件如下12345678# logging to stderr means we get it in the systemd journalKUBE_LOGTOSTDERR="--logtostderr=true"# journal message level, 0 is debugKUBE_LOG_LEVEL="--v=0"# Should this cluster be allowed to run privileged docker containersKUBE_ALLOW_PRIV="--allow-privileged=true"# How the controller-manager, scheduler, and proxy find the apiserverKUBE_MASTER="--master=http://k8s-master:8080" 修改kubelet文件如下123456789# The address for the info server to serve on (set to 0.0.0.0 or "" for all interfaces)KUBELET_ADDRESS="--address=0.0.0.0"# You may leave this blank to use the actual hostnameKUBELET_HOSTNAME="--hostname-override=k8s-slave1"# location of the api-serverKUBELET_API_SERVER="--api-servers=http://k8s-master:8080"# pod infrastructure container# 这个地址是使用的私有的harbor地址（docker images的仓库）KUBELET_POD_INFRA_CONTAINER="--pod-infra-container-image=192.168.12.200/myproj/pause-amd64:3.0" 1.2.4. 修改flannel的配置文件1vi /etc/sysconfig/flanneld 12345678# etcd url location. Point this to the server where etcd runsFLANNEL_ETCD_ENDPOINTS="http://k8s-master:2379"# etcd config key. This is the configuration key that flannel queries# For address range assignment# 必须与master节点配置flannel时的路径一致FLANNEL_ETCD_PREFIX="/kube-centos/network"# Any additional options that you want to pass#FLANNEL_OPTIONS="" 1.2.5. 重启服务12345for SERVICES in kube-proxy kubelet flanneld docker; do systemctl restart $SERVICES systemctl enable $SERVICES systemctl status $SERVICESdone 此时在master节点执行如下命令，验证是否能够查到该节点123$ kubectl get nodesNAME STATUS AGEk8s-node1 Ready 6d 2. skydns安装Kubernetes的DNS插件1) 先下载好四个组件包harbor.xxx.com/kube/kubedns-amd64:1.9harbor.xxx.com/kube/kube-dnsmasq-amd64:1.4harbor.xxx.com/kube/dnsmasq-metrics-amd64:1.0harbor.xxx.com/kube/exechealthz-amd64:1.22) 修改skydns-rc.yaml中对应的images地址3) 安装资源12kubectl create -f skydns-rc.yamlkubectl create -f skydns-svc.yaml 4) 在所有节点的/etc/kubernetes/kubelet最后一行修改为：1KUBELET_ARGS="--cluster-dns=10.254.0.100 --cluster-domain=cluster.local" 3. dashboard安装Kubernetes的WebUI1) 创建、下载dashboard的镜像harbor.xxx.com/kube/k8s‐dashboard:1.6.02) 使用kubenetes安装文件中的yaml文件来创建资源，修改如下字段123image: harbor.xxx.com/kube/k8s-dashboard:1.6.0imagePullPolicy: IfNotPresent - --apiserver-host=http://192.168.12.210:8080 3) 安装资源1kubectl create -f kubernetes-dashboard.yaml 4. heapster安装Kubernetes的性能监控插件1) 下载组件包：harbor.xxx.com/kube/heapster:canaryharbor.xxx.com/kube/heapster_influxdb:v0.5harbor.xxx.com/kube/heapster_grafana:v2.6.0-22) 修改heapster的配置文件，文件位置解压heapster-1.2.0.tar.gz文件heapster-1.2.0/deploy/kube-config/influxdb/3) 修改heapster-controller.yaml文件中对应images，然后修改最后两句为12- --source=kubernetes:http://192.168.12.210:8080?inClusterConfig=false- --sink=influxdb:http://monitoring-influxdb:8086 4) 修改influxdb-grafana-controller.yaml文件中的对应images地址。5) 安装资源12# (在heapster-1.2.0/deploy/kube-config/influxdb/目录中执行)kubectl create -f .]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker系列之二：构建CentOS7]]></title>
    <url>%2F2017%2FDocker_Series_Two_CentOS7%2F</url>
    <content type="text"><![CDATA[CentOS7的docker默认情况下是不能够执行systemctl命令的，抛出以下错误:Failed to get D-Bus connection: Operation not permitted从CentOS的官网上可以查询到解决该问题的办法，使用Dockerfile的方式来构建centos7的image。 1. CentOS7的DockerfileDockerfile的具体内容如下：123456789101112131415161718192021# centos的版本FROM centos:7ENV container docker# 在新建的images中使用systemctl命令RUN (cd /lib/systemd/system/sysinit.target.wants/; for i in *; do [ $i == \systemd-tmpfiles-setup.service ] || rm -f $i; done); \rm -f /lib/systemd/system/multi-user.target.wants/*;\rm -f /etc/systemd/system/*.wants/*;\rm -f /lib/systemd/system/local-fs.target.wants/*; \rm -f /lib/systemd/system/sockets.target.wants/*udev*; \rm -f /lib/systemd/system/sockets.target.wants/*initctl*; \rm -f /lib/systemd/system/basic.target.wants/*;\rm -f /lib/systemd/system/anaconda.target.wants/*; \# 安装ssh软件包（可选）yum -y install openssh-server; \yum -y install openssh-clients; \# 安装net工具（可选）yum -y install net-tools; \yum clean all;VOLUME [ "/sys/fs/cgroup" ]CMD ["/usr/sbin/init"] 执行命令如下命令即可完成centos7的image的构建1$ docker build --rm -t centos7:base . 2. 运行CentOS7的Container在构建完成之后，执行以下命令，即可运行1$ docker run --name centos_test -v /sys/fs/cgroup:/sys/fs/cgroup:ro --privileged -itd centos7:base 进入centos_test容器内部1$ docker exec -it test bash 启动ssh，不再报错，构建成功。1$ systemctl start sshd]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker系列之一：初识Docker]]></title>
    <url>%2F2017%2FDocker_Series_One_Introduction%2F</url>
    <content type="text"><![CDATA[近些年容器这个技术都比较火，刚好前端时间我们新项目的设计时就选用的容器+微服务的架构，因此在这记录下Docker的部署方法。 1. Docker简介Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 1.1. Docker VS VM从下图可以看出，VM是一个运行在宿主机之上的完整的操作系统，VM运行自身操作系统会占用较多的CPU、内存、硬盘资源。Docker不同于VM，只包含应用程序以及依赖库，基于libcontainer运行在宿主机上，并处于一个隔离的环境中，这使得Docker更加轻量高效，启动容器只需几秒钟之内完成。由于Docker轻量、资源占用少，使得Docker可以轻易的应用到构建标准化的应用中。但Docker目前还不够完善，比如隔离效果不如VM，共享宿主机操作系统的一些基础库等；网络配置功能相对简单，主要以桥接方式为主；查看日志也不够方便灵活。另外，IBM发表了一篇关于虚拟机和Linux container性能对比的论文，论文中实际测试了虚拟机和Linux container在CPU、内存、存储IO以及网络的负载情况，结果显示Docker容器本身几乎没有什么开销，但是使用AUFS会一定的性能损耗，不如使用Docker Volume，Docker的NAT在较高网络数据传输中会引入较大的工作负载，带来额外的开销。不过container的性能与native相差不多，各方面的性能都一般等于或者优于虚拟机。Container和虚拟机在IO密集的应用中都需要调整优化以更好的支持IO操作，两者在IO密集型的应用中都应该谨慎使用。 1.2. Docker主要特性 文件系统隔离：每个进程容器运行在完全独立的根文件系统里。 资源隔离：可以使用cgroup为每个进程容器分配不同的系统资源，例如CPU和内存。 网络隔离：每个进程容器运行在自己的网络命名空间里，拥有自己的虚拟接口和IP地址。 写时复制：采用写时复制方式创建根文件系统，这让部署变得极其快捷，并且节省内存和硬盘空间。 日志记录：Docker将会收集和记录每个进程容器的标准流（stdout/stderr/stdin），用于实时检索或批量检索。 变更管理：容器文件系统的变更可以提交到新的映像中，并可重复使用以创建更多的容器。无需使用模板或手动配置。 交互式Shell：Docker可以分配一个虚拟终端并关联到任何容器的标准输入上，例如运行一个一次性交互shell。 1.3. Docker主要应用场景 web应用的自动化打包和发布； 自动化测试和持续集成、发布； 在服务型环境中部署和调整数据库或其他的后台应用； 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。 2. 搭建Docker环境最新版本的Docker采用了年份+月份的版本发布规则，分为免费和商用两个版本（Docker-CE为免费版本/Docker-EE为商用版本）。而且Docker-CE仅支持64bit的系统。以下教程为在CentOS7的64bit系统中使用yum命令下载安装Docker。安装docker仓库1234sudo yum install -y yum-utilssudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo 获取最新版本的Docker CE1sudo yum -y install docker-ce 启动Docker进程1sudo systemctl start docker 测试Docker1sudo docker run hello-world 运行hello-world后如果控制台输出如下语句则表示Docker已经安装成功。12345678910111213141516171819Hello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the "hello-world" image from the Docker Hub. 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://cloud.docker.com/For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ 3. Docker简单命令查询Docker Hub中的镜像1234$ docker search javaNAME DESCRIPTION STARS OFFICIAL AUTOMATEDjava Java is a concurrent, class-based, and obj... 1368 [OK]ibmjava Official IBM® SDK, Java™ Technology Editio... 27 [OK] 下载Docker Hub中的镜像123456$ docker pull hello-worldUsing default tag: latestlatest: Pulling from library/hello-world78445dd45222: Already exists Digest: sha256:c5515758d4c5e1e838e9cd307f6c6a0d620b5e07e6f927b07d05f6d12a1ac8d7Status: Downloaded newer image for hello-world:latest 查看已下载的所有镜像1234$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEjava 8 d23bdf5b1b1b 4 months ago 643 MBhello-world latest 48b5124b2768 4 months ago 1.84 kB 运行一个新的容器1234567docker run -itd \ --name nginx_SSL \ #容器名称 -p 8011:80 -p 4433:443 \ #暴露端口 本机端口:容器端口 --link blog_mini:blog_mini \ #关联blog_mini容器 -v/data/nginx/config:/etc/nginx/conf.d \ #挂载本机的目录到容器 -v /data/nginx/logs:/var/log/nginx \ #挂载本机的目录到容器 nginx:1.13 #镜像 查看所有的容器1234$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES8cae4be0d7cb hello-world "/hello" 32 seconds ago Exited (0) 31 seconds ago dreamy_noethereccf37bf03b4 hello-world "/hello" 40 minutes ago Exited (0) 40 minutes ago youthful_franklin 常用Docker命令12345678docker info #显示Docker和系统信息docker start hello-world #启动容器docker stop hello-world #停止容器docker exec -it centos /bin/bash #执行centos容器的命令docker inspect centos #查看centos容器的信息docker cp /root/xx.zip centos:/root #复制文件到容器docker rm hello-world #删除hello-world容器docker rmi hello-world #删除hello-world镜像]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
</search>
